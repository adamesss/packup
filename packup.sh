#! /usr/bin/env bash

# This script will scan the current directory for files and pack them
# into a self-unpacking script. That script can then be sent out by
# itself with no other dependencies. This script will decend into
# nested directories.

# If the bash shell is too old
[ ${BASH_VERSINFO[0]} -le 2 ] && \
   echo "Bash version too old, aborting" && \
   exit 1

data=()
name=()
sum=()
md5command=""
index=0
output=${1:-"output.sh"}

##
# This will make sure that the support programs are installed
# and that the correct version is used depending on the system
# it is being run on (OSX and FreeBSD use md5, Linux md5sum)
check_for_programs() {
   which base64 >/dev/null 2>&1 || { 
      echo "Missing base64, aborting" 
      return 1 
   };

   which egrep >/dev/null 2>&1 || { 
      echo "Missing egrep, aborting" 
      return 1 
   };

   which tr >/dev/null 2>&1 || {
      echo "Missing tr, aborting"
      return 1
   };

   which md5sum >/dev/null 2>&1
   if [ $? -eq 0 ]; then
      md5command="md5sum"
   fi

   which md5 >/dev/null 2>&1
   if [ $? -eq 0 ]; then
      md5command="md5"
   fi

   [ -z $md5command ] && { 
      echo "Missing md5 command (md5 or md5sum), aborting" 
      return 1 
   };

   return 0
}

##
# this function will get the md5sum for a file and return
# just the hash
md5() {
   command $md5command "$1" | egrep -o "[0-9a-fA-F]{32}"
}

##
# This will copy over the necessary functions to the
# packed script so it can unpack itself
write_script_function() {
   type "$1" | tail -n +2 >> "$output" 
   echo "" >> "$output"
}

###############################################################
## These functions are the user hooks that can be overridden ##
###############################################################

##
# This function is a user hook to allow a developer to inject
# their own code into the header of the packed script. This
# will be called after the write_script_header function
user_header() {
   return 0
}

##
# This function is a user hook to allow a developer to inject
# their own code into the footer of the packed script. This
# will be called after the write_script_footer function
user_footer() {
   return 0
}

##
# This function is a user hook to allow a developer to inject
# their own code into this script. The pre_run will be called 
# from the packed scriptbefore any data is unpacked from it. 
pre_run() {
   return 0
}

## 
# This function is a user hook to allow a developer to inject
# their own code into this script. The post_run function will
# be executed after all of the files have been unpacked
post_run() {
   return 0
}

#############################################################
## End of user hook function ################################
#############################################################

##
# This function will recurrisvly pack up the files in a
# directory
pack_up_dir() {
   local dirname="$1"

   for file in *; do
      if [ -d "$file" -a -r "$file" ]; then
         pushd "$file"
         pack_up_dir "${dirname}${file}/"
         popd
      elif [ -f "$file" -a -r "$file" ]; then
         echo "packing ${dirname}${file}"
         name[$index]="${dirname}${file}"
         sum[$index]=$(md5 "${file}")
         data[$index]=$(base64 "${file}" | tr -d [:space:])
         (( index++ ))
      fi
   done
}

##
# This function will unpack the data from the packed
# script
unpack_data() {
   echo ""
   local index=0
   local num=${#name[@]}
   local dir=""
   
   for (( i=0; i < $num; i++ )); do
      echo "Unpacking ${name[$i]}"

      dir=$(dirname "${name[$i]}")
      if [ "$dir" != "." ]; then
         mkdir -p "$dir"
      fi

      echo ${data[$i]} | base64 -d > "${name[$i]}"
      if [ "$(md5 "${name[$i]}")" != "${sum[$i]}" ]; then
         echo "Failed to verify checksum for ${name[$i]}"
         exit 1
      fi

   done
}

##
# This will output the header for the packed script
write_script_header() {
   cat <<- "EOF" > "$output"
#! /usr/bin/env bash
# The script was auto-generated by packup.sh, to unpack
# it just execute this script in the desired directory.

name=()
sum=()
data=()
md5command=""

echo -n "Loading packed resources"
EOF
}

##
# This will write out the data in packed form to the 
# packed script. 
write_packed_data() {
   echo "writing packed data to $output"
   local index=0
   local num=${#name[@]}
   for (( i=0; i < num; i++ )); do
      echo "name[$i]=\"${name[$i]}\"" >> "$output"
      echo "sum[$i]=\"${sum[$i]}\"" >> "$output"
      echo "data[$i]=\"${data[$i]}\"" >> "$output"
      echo "echo -n \".\"" >> "$output"
      echo "" >> "$output"
   done
}

write_script_footer() {
   echo "check_for_programs" >> "$output"
   echo '[ $? -ne 0 ] && exit 1' >> "$output"
   echo "pre_run" >> "$output"
   echo "unpack_data" >> "$output"
   echo "post_run" >> "$output"
}

## 
# This is like the "main" function that will execute
# the pack program
run_pack() {

   # Make sure we have the requiered programs
   check_for_programs
   [ $? -ne 0 ] && exit 1

   #pack up the data in the current directory
   pack_up_dir

   # write out the requied script fucntions to the 
   # output script
   write_script_header
   user_header
   write_script_function "check_for_programs"
   write_script_function "md5"
   write_script_function "pre_run"
   write_script_function "unpack_data"
   write_script_function "post_run"
   write_packed_data
   write_script_footer
   user_footer
   chmod +x "$output"
}

# If we are not being sourced (AKA being executed directly) then
# run the packup as-is, if it is being source, the user will have 
# to call this at the end of their script
if [ "$BASH_SOURCE" == "$0" ]; then
   run_pack
fi
